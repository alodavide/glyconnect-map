<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../lib-d3/lib-d3.html">
<!--
`glyconnect-map`
First map in glyconnect
@demo demo/index.html
-->

<dom-module id="glyconnect-map">
  <template>
    <style>
      :host {
        display: block;
      }

      svg {
        display: block;
        margin: auto;
        font: 12px sans-serif;
      }

      text {
        pointer-events: none;
      }

      .inner_node rect {
        pointer-events: all;
      }

      .inner_node rect.highlight {
        stroke: #315B7E;
        stroke-width: 2px;
      }

      .outer_node circle {
        fill: #fff;
        stroke: steelblue;
        stroke-width: 1.5px;
        pointer-events: all;
      }

      .outer_node circle.highlight
      {
        stroke: #315B7E;
        stroke-width: 2px;
      }

      .link {
        fill: none;
      }

      .clicked {
        stroke: steelblue;
        stroke-width: 4px;
      }

      .center {
        display:block;
        margin:auto;
      }

      .hidden {
        display: none;
      }

    </style>
    <div id="map" class="center"></div>

    <div id="nores" class$="{{noResClass}}">
      <img src="{{octopusImg}}" />
    </div>

    <iron-ajax
            id="request"
            url="{{apiServer}}/api/compositions"
            handle-as="json"
            on-response="createOctopus"
            on-error="handleError"
    ></iron-ajax>
  </template>

  <script>
    /** @polymerElement */
    class GlyconnectMap extends Polymer.Element {
      static get is() { return 'glyconnect-map'; }
      static get properties() {
        return {
          pageType: {
            type: String,
            notify: true,
            reflectToAttribute: true
          },
          filterData: {
            type: Object,
            reflectToAttribute: true,
            observer: '_makeRequest'
          },
          structureId: {
            type: String,
            reflectToAttribute: true,
            notify: true
          },
          proteinId: {
            type: String,
            reflectToAttribute: true,
            notify: true
          },
          apiServer:{
            type:String
          }
        };
      }

      connectedCallback(){
        this.octopusImg = this.resolveUrl('./img/octopusGlyconnect.png');
        this.noResClass = 'hidden center';
      }

      _makeRequest(filterData){
        if(filterData !== undefined){
          var request = this.$.request;
          request.set( 'params', filterData);
          request.generateRequest();
        }
      }

      handleError(){

        //Todo: handle 500 or error in the connection!
        this.octopusImg = this.resolveUrl('./img/octopusGlyconnect.png');
        var map = this.$.map;
        map.innerHTML = '';
        this.noResClass = 'center';
        map.scrollIntoView({block: "start", behavior: "smooth"});
      }

      createOctopus(data){
        this.octopusImg = this.resolveUrl('./img/octopusGlyconnect.png');
        var responseData = data.detail.response;
        this.noResClass = 'hidden center';
        var map = this.$.map;
        map.innerHTML = '';

        if(responseData === undefined || responseData === '' || responseData.length === 0){
          this.noResClass = 'center';
          map.scrollIntoView({block: "start", behavior: "smooth"});
          return;
        }

        var that = this;
        var outerLeft = d3.map();
        var outerRight = d3.map();
        var inner = [];
        var links = [];

        var outerId = [0];

        responseData.forEach(function(d) {
          // Inner
          if (d == null)
            return;

          var i = {id: 'i' + inner.length, name: that.compositionToString(d.composition), related_links: []};
          i.related_nodes = [i.id];
          inner.push(i);

          if (d.proteins) {
            //outer right
            d.proteins.forEach(function (d1) {

              var o = outerRight.get(d1.id);

              if (o == null) {
                var name;
                if(d1.uniprot && d1.uniprot.length >1){
                  name = 'Complex_'+d1.uniprot[0];
                }
                if(d1.uniprot && d1.uniprot.length === 1){
                  name = d1.uniprot[0];
                }
                if(!d1.uniprot){
                  name = 'Protein_'+d1.id;
                }
                o = {protein_id: d1.id, id: 'o' + outerId[0], name: name, type:'protein', related_links: []};
                o.related_nodes = [o.id];
                outerId[0] = outerId[0] + 1;

                outerRight.set(d1.id, o);
              }

              // create the links
              var l = {id: 'l-' + i.id + '-' + o.id, inner: i, outer: o}
              links.push(l);

              // and the relationships
              i.related_nodes.push(o.id);
              i.related_links.push(l.id);
              o.related_nodes.push(i.id);
              o.related_links.push(l.id);
            });
          }

          //outer left
          if(d.structures){
            d.structures.forEach(function (d1) {

              var o = outerLeft.get(d1);

              if (o == null) {
                o = {structure_id: d1, name: 'S' + d1, id: 'o' + outerId[0], type: 'glycan', related_links: []};
                o.related_nodes = [o.id];
                outerId[0] = outerId[0] + 1;
                outerLeft.set(d1, o);
              }

              // create the links
              var l = {id: 'l-' + i.id + '-' + o.id, inner: i, outer: o};
              links.push(l);

              // and the relationships
              i.related_nodes.push(o.id);
              i.related_links.push(l.id);
              o.related_nodes.push(i.id);
              o.related_links.push(l.id);
            });
          }
        });

        var data = {
          inner: inner,
          outerLeft: outerLeft.values(),
          outerRight: outerRight.values(),
          links: links
        }


        // from d3 colorbrewer:
        // This product includes color specifications and designs developed by Cynthia Brewer (http://colorbrewer.org/).
        var colors = ["#a50026","#d73027","#f46d43","#fdae61","#fee090","#ffffbf","#e0f3f8","#abd9e9","#74add1","#4575b4","#313695"]
        var color = d3.scale.linear()
            .domain([60, 220])
            .range([colors.length-1, 0])
            .clamp(true);

        var diameter = 960;
        var rect_width = 70;
        var rect_height = 20;

        var link_width = "1px";

        var il = data.inner.length;

        var inner_y = d3.scale.linear()
            .domain([0, il])
            .range([-(il * rect_height)/2, (il * rect_height)/2]);

        var mid = data.outerLeft.length;
        var outer_x = d3.scale.linear()
            .domain([0, mid, mid, data.outerRight.length+data.outerLeft.length])
            .range([15, 170, 190 ,355]);


        // setup positioning
        data.outerLeft = data.outerLeft.map(function(d, i) {
          d.x = outer_x(i);
          d.y = diameter/3;
          return d;
        });

        data.outerRight = data.outerRight.map(function(d, i) {
          d.x = outer_x(i+data.outerLeft.length);
          d.y = diameter/3;
          return d;
        });

        data.outer = data.outerLeft.concat(data.outerRight);
        data.inner = data.inner.map(function(d, i) {
          d.x = -(rect_width / 2);
          d.y = inner_y(i);
          return d;
        });

        function get_color(name)
        {
          var c = Math.round(color(name));
          if (isNaN(c))
            return '#dddddd';	// fallback color

          return colors[c];
        }

        // Can't just use d3.svg.diagonal because one edge is in normal space, the
        // other edge is in radial space. Since we can't just ask d3 to do projection
        // of a single point, do it ourselves the same way d3 would do it.


        function projectX(x)
        {
          return ((x - 90) / 180 * Math.PI) - (Math.PI/2);
        }

        var diagonal = d3.svg.diagonal()
            .source(function(d) { return {"x": d.outer.y * Math.cos(projectX(d.outer.x)),
              "y": -d.outer.y * Math.sin(projectX(d.outer.x))}; })
            .target(function(d) { return {"x": d.inner.y + rect_height/2,
              "y": d.outer.x > 180 ? d.inner.x : d.inner.x + rect_width}; })
            .projection(function(d) { return [d.y, d.x]; });


        var svg = d3.select(map).append("svg")
            .attr("width", diameter)
            .attr("height", diameter)
            .append("g")
            .attr("transform", "translate(" + diameter / 2 + "," + diameter / 2 + ")");


        // links
        var link = svg.append('g').attr('class', 'links').selectAll(".link")
            .data(data.links)
            .enter().append('path')
            .attr('class', 'link')
            .attr('id', function(d) { return d.id })
            .attr("d", diagonal)
            .attr('stroke', function(d) { return get_color(d.inner.name); })
            .attr('stroke-width', link_width);

        // outer nodes
        var onode = svg.append('g').selectAll(".outer_node")
            .data(data.outer)
            .enter().append("g")
            .attr("class", "outer_node")
            .attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; })
            .on("mouseover", this.mouseover)
            .on("mouseout", this.mouseout)
            .on("click", function(e){
              that.pageType = e.type;
              if(e.type === 'protein'){
                //Force proteinId to change
                that.proteinId = undefined;
                that.proteinId = e.protein_id;
              } else {
                that.structureId = undefined;
                that.structureId = e.structure_id;
              }
            });

        onode.append("circle")
            .attr('id', function(d) { return d.id })
            .attr("r", 4.5);

        onode.append("circle")
            .attr('r', 20)
            .attr('visibility', 'hidden');

        onode.append("text")
            .attr('id', function(d) { return d.id + '-txt'; })
            .attr("dy", ".31em")
            .attr("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
            .attr("transform", function(d) { return d.x < 180 ? "translate(8)" : "rotate(180)translate(-8)"; })
            .text(function(d) { return d.name; });

        // inner nodes

        var inode = svg.append('g').selectAll(".inner_node")
            .data(data.inner)
            .enter().append("g")
            .attr("class", "inner_node")
            .attr("transform", function(d, i) { return "translate(" + d.x + "," + d.y + ")"})
            .on("mouseover", this.mouseover)
            .on("mouseout", this.mouseout)
            .on("click", this.click);

        inode.append('rect')
            .attr('width', rect_width)
            .attr('height', rect_height)
            .attr('id', function(d) { return d.id; })
            .attr('fill', function(d) { return get_color(d.name); });

        inode.append("text")
            .attr('id', function(d) { return d.id + '-txt'; })
            .attr('text-anchor', 'middle')
            .attr("transform", "translate(" + rect_width/2 + ", " + rect_height * .75 + ")")
            .text(function(d) { return d.name; });

        // need to specify x/y/etc

        d3.select(self.frameElement).style("height", diameter - 150 + "px");
        map.scrollIntoView({block: "start", behavior: "smooth"});

      }

      click(d) {

        for (var i = 0; i < d.related_links.length; i++) {
          var link = d3.select(Polymer.dom(this.farthestViewportElement).querySelector('#' + d.related_links[i]))
          if (link.classed('clicked')) {
            link.classed('clicked', false);
          } else {
            link.classed('clicked', true);
          }
        }
      }



      mouseover(d) {

        d3.selectAll('.links .link').sort(function(a, b){ return d.related_links.indexOf(a.id); });

        for (var i = 0; i < d.related_nodes.length; i++)
        {
          d3.select(Polymer.dom(this.farthestViewportElement).querySelector('#' + d.related_nodes[i])).classed('highlight', true);
          d3.select(Polymer.dom(this.farthestViewportElement).querySelector('#' + d.related_nodes[i] + '-txt')).attr("font-weight", 'bold');
        }

        for (var i = 0; i < d.related_links.length; i++)
          d3.select(Polymer.dom(this.farthestViewportElement).querySelector('#' + d.related_links[i])).attr('stroke-width', '5px');
      }

      mouseout(d) {

        for (var i = 0; i < d.related_nodes.length; i++)
        {
          d3.select(Polymer.dom(this.farthestViewportElement).querySelector('#' + d.related_nodes[i])).classed('highlight', false);
          d3.select(Polymer.dom(this.farthestViewportElement).querySelector('#' + d.related_nodes[i] + '-txt')).attr("font-weight", 'normal');
        }

        for (var i = 0; i < d.related_links.length; i++)
          d3.select(Polymer.dom(this.farthestViewportElement).querySelector('#' + d.related_links[i])).attr('stroke-width', '1px');

      }


      compositionToString(composition){
        var tokens = composition.split(',');
        var outputString = '';
        if (tokens[0] !== "0") {
          outputString += 'H' + tokens[0];
        }
        if (tokens[1] !== "0") {
          outputString += 'N' + tokens[1];
        }
        if (tokens[2] !== "0") {
          outputString += 'F' + tokens[2];
        }
        if (tokens[3] !== "0") {
          outputString += 'S' + tokens[3];
        }
        if (tokens[4] !== "0") {
          outputString += 'G' + tokens[4];
        }
        if (tokens[5] !== "0") {
          outputString += 'P' + tokens[5];
        }
        if (tokens[6] !== "0") {
          outputString += 's' + tokens[6];
        }
        if (tokens[7] !== "0") {
          outputString += 'p' + tokens[7];
        }
        if (tokens[11] !== "0") {
          outputString += 'm' + tokens[11];
        }
        if (tokens[12] !== "0") {
          outputString += 'a' + tokens[12];
        }
        return outputString;
      }
    }

    window.customElements.define(GlyconnectMap.is, GlyconnectMap);
  </script>
</dom-module>