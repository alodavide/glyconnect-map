<link rel="import" href="../polymer/polymer-element.html">
<script src="https://d3js.org/d3.v3.min.js"></script>
<!--
`glyconnect-map`
First map in glyconnect

@demo demo/index.html
-->

<dom-module id="glyconnect-map">
  <template>
    <style>
      :host {
        display: block;
      }

      svg {
        font: 12px sans-serif;
      }

      text {
        pointer-events: none;
      }

      .inner_node rect {
        pointer-events: all;
      }

      .inner_node rect.highlight {
        stroke: #315B7E;
        stroke-width: 2px;
      }

      .outer_node circle {
        fill: #fff;
        stroke: steelblue;
        stroke-width: 1.5px;
        pointer-events: all;
      }

      .outer_node circle.highlight
      {
        stroke: #315B7E;
        stroke-width: 2px;
      }

      .link {
        fill: none;
      }

      svg {
        display: block;
        margin: auto;
      }
    </style>
    <div id="map" style="display:block; margin:auto"></div>
  </template>

  <script>
    /** @polymerElement */
    class GlyconnectMap extends Polymer.Element {
      static get is() { return 'glyconnect-map'; }
      static get properties() {
        return {
          changePage: {
            type: String,
            notify: true,
            reflectToAttribute: true
          },
          octData: {
            type: Object,
            reflectToAttribute: true,
            observer: 'createOctopus'
          },
          structureId: {
            type: String,
            reflectToAttribute: true,
            notify: true
          },
          proteinId: {
            type: String,
            reflectToAttribute: true,
            notify: true
          }
        };
      }

      createOctopus(){
        var map = this.$.map;
        map.innerHTML = '';

        if(this.octData == undefined || this.octData == ''){
          var img = document.createElement('img');
          img.src = this.resolveUrl('./img/octopusGlyconnect.png');
          Polymer.dom(map).appendChild(img);
          return;
        }
        // Way to force polymer to apply style to D3 svg.
        this.scopeSubtree(this.$.map, true);
        var that = this;
        var data = [];
        for(var i = 0; i < this.octData.length; i++){
          var singleArray = [];
          if(!this.octData[i].proteins){
            this.octData[i].proteins = []
          } else {
            for(var j=0;j<this.octData[i].proteins.length;j++){
              this.octData[i].proteins[j]="P"+this.octData[i].proteins[j];
            }
          }
          if(!this.octData[i].structures){
            this.octData[i].structures = []
          } else {
            for(var j=0;j<this.octData[i].structures.length;j++){
              this.octData[i].structures[j]="S"+this.octData[i].structures[j];
            }
          }
          singleArray.push(this.compositionToString(this.octData[i].composition));
          singleArray.push(this.octData[i].structures);
          singleArray.push(this.octData[i].proteins);
          data.push(singleArray);
        }

        // transform the data into a useful representation
        // 1 is inner, 2, is outer

        // need: inner, outer, links
        //
        // inner:
        // links: { inner: outer: }


        var outerLeft = d3.map();
        var outerRight = d3.map();
        var inner = [];
        var links = [];

        var outerId = [0];

        data.forEach(function(d){

          if (d == null)
            return;

          i = { id: 'i' + inner.length, name: d[0], related_links: [] };
          i.related_nodes = [i.id];
          inner.push(i);

          if (!Array.isArray(d[1]))
            d[1] = [d[1]];
          //outer left
          d[1].forEach(function(d1){

            o = outerRight.get(d1);

            if (o == null)
            {
              o = { name: d1,	id: 'o' + outerId[0], related_links: [] };
              o.related_nodes = [o.id];
              outerId[0] = outerId[0] + 1;

              outerRight.set(d1, o);
            }

            // create the links
            l = { id: 'l-' + i.id + '-' + o.id, inner: i, outer: o }
            links.push(l);

            // and the relationships
            i.related_nodes.push(o.id);
            i.related_links.push(l.id);
            o.related_nodes.push(i.id);
            o.related_links.push(l.id);
          });
          //outer right
          if (!Array.isArray(d[2]))
            d[1] = [d[1]];
          d[2].forEach(function(d1){

            o = outerLeft.get(d1);

            if (o == null)
            {
              o = { name: d1,	id: 'o' + outerId[0], related_links: [] };
              o.related_nodes = [o.id];
              outerId[0] = outerId[0] + 1;

              outerLeft.set(d1, o);
            }

            // create the links
            l = { id: 'l-' + i.id + '-' + o.id, inner: i, outer: o }
            links.push(l);

            // and the relationships
            i.related_nodes.push(o.id);
            i.related_links.push(l.id);
            o.related_nodes.push(i.id);
            o.related_links.push(l.id);
          });
        });

        data = {
          inner: inner,
          outerLeft: outerLeft.values(),
          outerRight: outerRight.values(),
          links: links
        }


        // from d3 colorbrewer:
        // This product includes color specifications and designs developed by Cynthia Brewer (http://colorbrewer.org/).
        var colors = ["#a50026","#d73027","#f46d43","#fdae61","#fee090","#ffffbf","#e0f3f8","#abd9e9","#74add1","#4575b4","#313695"]
        var color = d3.scale.linear()
                .domain([60, 220])
                .range([colors.length-1, 0])
                .clamp(true);

        var diameter = 960;
        var rect_width = 40;
        var rect_height = 14;

        var link_width = "1px";

        var il = data.inner.length;

        var inner_y = d3.scale.linear()
                .domain([0, il])
                .range([-(il * rect_height)/2, (il * rect_height)/2]);

        mid = data.outerLeft.length;
        var outer_x = d3.scale.linear()
                .domain([0, mid, mid, data.outerRight.length+data.outerLeft.length])
                .range([15, 170, 190 ,355]);


        // setup positioning
        data.outerLeft = data.outerLeft.map(function(d, i) {
          d.x = outer_x(i);
          d.y = diameter/3;
          return d;
        });

        data.outerRight = data.outerRight.map(function(d, i) {
          d.x = outer_x(i+data.outerLeft.length);
          d.y = diameter/3;
          return d;
        });

        data.outer = data.outerLeft.concat(data.outerRight);
        data.inner = data.inner.map(function(d, i) {
          d.x = -(rect_width / 2);
          d.y = inner_y(i);
          return d;
        });

        function get_color(name)
        {
          var c = Math.round(color(name));
          if (isNaN(c))
            return '#dddddd';	// fallback color

          return colors[c];
        }

        // Can't just use d3.svg.diagonal because one edge is in normal space, the
        // other edge is in radial space. Since we can't just ask d3 to do projection
        // of a single point, do it ourselves the same way d3 would do it.


        function projectX(x)
        {
          return ((x - 90) / 180 * Math.PI) - (Math.PI/2);
        }

        var diagonal = d3.svg.diagonal()
                .source(function(d) { return {"x": d.outer.y * Math.cos(projectX(d.outer.x)),
                  "y": -d.outer.y * Math.sin(projectX(d.outer.x))}; })
                .target(function(d) { return {"x": d.inner.y + rect_height/2,
                  "y": d.outer.x > 180 ? d.inner.x : d.inner.x + rect_width}; })
                .projection(function(d) { return [d.y, d.x]; });


        var svg = d3.select(map).append("svg")
                .attr("width", diameter)
                .attr("height", diameter)
                .append("g")
                .attr("transform", "translate(" + diameter / 2 + "," + diameter / 2 + ")");


        // links
        var link = svg.append('g').attr('class', 'links').selectAll(".link")
                .data(data.links)
                .enter().append('path')
                .attr('class', 'link')
                .attr('id', function(d) { return d.id })
                .attr("d", diagonal)
                .attr('stroke', function(d) { return get_color(d.inner.name); })
                .attr('stroke-width', link_width);

        // outer nodes
        var onode = svg.append('g').selectAll(".outer_node")
                .data(data.outer)
                .enter().append("g")
                .attr("class", "outer_node")
                .attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; })
                .on("mouseover", this.mouseover)
                .on("mouseout", this.mouseout)
                .on("click", function(e){
                  if(e.name.indexOf("P") != -1){
                    that.changePage= "protein";
                    that.proteinId = e.name.substring(1);
                  }
                  if(e.name.indexOf("S") != -1){
                    that.changePage = 'structure';
                    that.structureId = e.name.substring(1);
                  }
                });

        onode.append("circle")
                .attr('id', function(d) { return d.id })
                .attr("r", 4.5);

        onode.append("circle")
                .attr('r', 20)
                .attr('visibility', 'hidden');

        onode.append("text")
                .attr('id', function(d) { return d.id + '-txt'; })
                .attr("dy", ".31em")
                .attr("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
                .attr("transform", function(d) { return d.x < 180 ? "translate(8)" : "rotate(180)translate(-8)"; })
                .text(function(d) { return d.name; });

        // inner nodes

        var inode = svg.append('g').selectAll(".inner_node")
                .data(data.inner)
                .enter().append("g")
                .attr("class", "inner_node")
                .attr("transform", function(d, i) { return "translate(" + d.x + "," + d.y + ")"})
                .on("mouseover", this.mouseover)
                .on("mouseout", this.mouseout);

        inode.append('rect')
                .attr('width', rect_width)
                .attr('height', rect_height)
                .attr('id', function(d) { return d.id; })
                .attr('fill', function(d) { return get_color(d.name); });

        inode.append("text")
                .attr('id', function(d) { return d.id + '-txt'; })
                .attr('text-anchor', 'middle')
                .attr("transform", "translate(" + rect_width/2 + ", " + rect_height * .75 + ")")
                .text(function(d) { return d.name; });

        // need to specify x/y/etc

        d3.select(self.frameElement).style("height", diameter - 150 + "px");

      }

      mouseover(d) {

        d3.selectAll('.links .link').sort(function(a, b){ return d.related_links.indexOf(a.id); });

        for (var i = 0; i < d.related_nodes.length; i++)
        {
          d3.select(Polymer.dom(this.farthestViewportElement).querySelector('#' + d.related_nodes[i])).classed('highlight', true);
          d3.select(Polymer.dom(this.farthestViewportElement).querySelector('#' + d.related_nodes[i] + '-txt')).attr("font-weight", 'bold');
        }

        for (var i = 0; i < d.related_links.length; i++)
          d3.select(Polymer.dom(this.farthestViewportElement).querySelector('#' + d.related_links[i])).attr('stroke-width', '5px');
      }

      mouseout(d) {

        for (var i = 0; i < d.related_nodes.length; i++)
        {
          d3.select(Polymer.dom(this.farthestViewportElement).querySelector('#' + d.related_nodes[i])).classed('highlight', false);
          d3.select(Polymer.dom(this.farthestViewportElement).querySelector('#' + d.related_nodes[i] + '-txt')).attr("font-weight", 'normal');
        }

        for (var i = 0; i < d.related_links.length; i++)
          d3.select(Polymer.dom(this.farthestViewportElement).querySelector('#' + d.related_links[i])).attr('stroke-width', '1px');

      }


      compositionToString(composition){
        var outputString = '';
        if(composition.charAt(0) != "0"){
          outputString += 'H'+composition.charAt(0);
        }
        if(composition.charAt(1) != "0"){
          outputString += 'N'+composition.charAt(1);
        }
        if(composition.charAt(2) != "0"){
          outputString += 'F'+composition.charAt(2);
        }
        if(composition.charAt(3) != "0"){
          outputString += 'S'+composition.charAt(3);
        }
        if(composition.charAt(4) != "0"){
          outputString += 'G'+composition.charAt(4);
        }
        if(composition.charAt(5) != "0"){
          outputString += 'P'+composition.charAt(5);
        }
        if(composition.charAt(6) != "0"){
          outputString += 's'+composition.charAt(6);
        }
        if(composition.charAt(7) != "0"){
          outputString += 'p'+composition.charAt(7)
        }
        if(composition.charAt(11) != "0"){
          outputString += 'm'+composition.charAt(11)
        }
        if(composition.charAt(12) != "0"){
          outputString += 'a'+composition.charAt(11)
        }
        return outputString;
      }
    }

    window.customElements.define(GlyconnectMap.is, GlyconnectMap);
  </script>
</dom-module>
